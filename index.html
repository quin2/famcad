<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>mosaicmosaic</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.0/tween.umd.js"></script>
    <script type="text/javascript" src="map.json"></script>
		<script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
    
      let width = dataMap.length;
      let height = dataMap[0].length;
      
      let tileSize = 2;
      
      var allowClicks = true;
      
      var openTile = NaN;
      var oldPos = NaN;
      
      //make covering plane for use later.
      var coverObj = new THREE.PlaneBufferGeometry(dataMap[0].length *tileSize, dataMap.length *tileSize, 32 );
      var coverPlaneMaterial = new THREE.MeshBasicMaterial( {color: 0x000000, opacity: 0.0, transparent: true} );
      var coverPlane = new THREE.Mesh( coverObj, coverPlaneMaterial);
      coverPlane.position.z = 0.2 //get it close to original grid...
      coverPlane.position.x = (dataMap[0].length/tileSize)
      coverPlane.position.y = -1 * (dataMap.length / tileSize)
      
      const loader = new THREE.TextureLoader();
      var loadingScreen = new THREE.PlaneBufferGeometry(5, 5, 32 );
      var loadingMaterial = new THREE.MeshBasicMaterial( {map: loader.load("https://cdn.glitch.com/64c89c91-2aaf-438f-810f-2362a5130d44%2Fgiphy.gif?v=1599514918332")});
      var loadingPlane = new THREE.Mesh( loadingScreen, loadingMaterial);
      loadingPlane.position.z = 0.3
      
      console.log(loadingPlane)
      
      scene.add(loadingPlane);
      renderer.render(scene,camera)
      
      for(var i = 0; i < width; i++){
        for(var j = 0; j < height; j++){
          var geometry = new THREE.BoxBufferGeometry( tileSize, tileSize, 0.1);
          
          //address example is https://quin2pm.s3.us-east-2.amazonaws.com/XXX.jpg
          const loader = new THREE.TextureLoader();
          const texString = "https://quin2pm.s3.us-east-2.amazonaws.com/" + dataMap[i][j] + ".jpg";
          
          var materials = [
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true}),
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true} ),
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true} ),
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true} ),
            new THREE.MeshBasicMaterial( {map: loader.load(texString), transparent:true} ),
            new THREE.MeshBasicMaterial( {color: 0x00FF00, transparent:true} ),
          ]
          
          var plane = new THREE.Mesh( geometry, materials);
          plane.clickable = true;
          scene.add( plane );
          plane.position.set(j, -1 * i, 0.1);
        }
      }
      
      scene.remove(loadingPlane);
      
      //center camera
      var centerx = ((height/4) * tileSize);
      var centery = -((width/4) * tileSize);
      camera.position.x = centerx;
      camera.position.y = centery;
      
      //scroll wheel to adj j 
      camera.position.z = 40;
      
      renderer.render(scene, camera)
      
      //listen to scroll wheel
      window.addEventListener("wheel", function(e) {
        //camera.position.z += -1 * (e.deltaY / 20);
        
        //this seems a little smoother...
        
        if(e.deltaY < 0){
          if(camera.position.z < 100){
            camera.position.z++;
          }
        } else {
          if(camera.position.z > 2){
            camera.position.z--;
          }
        }

      }, true);
      
      
      function onMouseClick( event ) {
        if(!allowClicks){
          //run animations in reverse
          console.log(oldPos)
          
          var flipOver = new TWEEN.Tween(openTile.rotation).to({y: 0}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.scale).to({x: 4, y: 4}, 1000).start();
            new TWEEN.Tween(coverPlane.material).to({opacity:0.0}, 1000).start();
            new TWEEN.Tween(openTile.position).to({x: oldPos.x, y: oldPos.y}, 1000).start();
          }).start();
          
          var changeScale = new TWEEN.Tween(openTile.scale).to({x: 1, y: 1}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.position).to({z: 0.1}, 1000).start();
          }).onComplete(function(){
            openTile.material[4] = new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true});
            openTile.clickable = false;
            scene.remove(coverPlane);
            allowClicks = true;
            
          })

          //start everything
          flipOver.chain(changeScale);

        }
        
        // update the picking ray with the camera and mouse position
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( scene.children );
        
        
        if (typeof intersects[3] !== 'undefined' && allowClicks && intersects[3].object.clickable){
          allowClicks = false;
          scene.add( coverPlane );
          
          openTile = intersects[3].object;
          oldPos.x = openTile.position.x;
          oldPos.y = openTile.position.y;
          console.log(oldPos)

          //animate scale change
          var changeScale = new TWEEN.Tween(openTile.scale).to({x: 2,y: 2}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.position).to({z: 1.0}, 1000).start();
          }).start();

          //is there a better const for pi?
          //animate flip over
          var flipOver = new TWEEN.Tween(openTile.rotation).to({y: 3.14159}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.scale).to({x: 5, y: 2.5}, 1000).start();
            new TWEEN.Tween(coverPlane.material).to({opacity:0.5}, 1000).start();
            new TWEEN.Tween(openTile.position).to({x: centerx, y: centery}, 1000).start();
          })

          //start everything
          changeScale.chain(flipOver);
        }
      }
      
      window.addEventListener( 'click', onMouseClick, false );
      
      renderer.setAnimationLoop(() => {
        TWEEN.update();
        renderer.render(scene, camera);
      });
		</script>

    <!-- include the Glitch button to show what the webpage is about and
          to make it easier for folks to view source and remix -->
    <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
    <script src="https://button.glitch.me/button.js"></script>
  </body>
</html>

<!--
get stuff to center actually...


TODO:
force mosaic OP images to be power of two (128x128)

in order to add text, we will have to draw to canvas, then apply as mesh surface for each individual.....
possibly pre-render and display as back mesh texture, then overlay with the 'real element' later? 

get working for touch...

advanced: change LOD as images are zoomed in? 

issue could be with tiles filling in extra space...possibly remove first stage scale
-->