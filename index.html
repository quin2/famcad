<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>mosaicmosaic</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.0/tween.umd.js"></script>
    <script type="text/javascript" src="map.json"></script>
		<script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
    
      let width = dataMap.length;
      let height = dataMap[0].length;
      
      let tileSize = 2;
      
      var allowClicks = true;
      
      var openTile = NaN;
      
      //make covering plane for use later.
      var coverObj = new THREE.PlaneBufferGeometry(dataMap[0].length *tileSize, dataMap.length *tileSize, 32 );
      var coverPlaneMaterial = new THREE.MeshBasicMaterial( {color: 0x000000, opacity: 0.0, transparent: true} );
      var coverPlane = new THREE.Mesh( coverObj, coverPlaneMaterial);
      coverPlane.position.z = 0.2 //get it close to original grid...
      coverPlane.position.x = (dataMap[0].length/tileSize)
      coverPlane.position.y = -1 * (dataMap.length / tileSize)
      
      for(var i = 0; i < width; i++){
        for(var j = 0; j < height; j++){
          var geometry = new THREE.BoxBufferGeometry( tileSize, tileSize, 0.1);
          
          //address example is https://quin2pm.s3.us-east-2.amazonaws.com/XXX.jpg
          const loader = new THREE.TextureLoader();
          const texString = "https://quin2pm.s3.us-east-2.amazonaws.com/" + dataMap[i][j] + ".jpg";
          
          var materials = [
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true}),
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true} ),
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true} ),
            new THREE.MeshBasicMaterial( {color: 0x000000, transparent:true} ),
            new THREE.MeshBasicMaterial( {map: loader.load(texString), transparent:true} ),
            new THREE.MeshBasicMaterial( {color: 0x00FF00, transparent:true} ),
          ]
          
          var plane = new THREE.Mesh( geometry, materials);
          scene.add( plane );
          plane.position.set(j, -1 * i, 0.1);
        }
      }
      
      //center camera
      camera.position.x = ((height/4) * tileSize);
      camera.position.y = -((width/4) * tileSize)
      
      //scroll wheel to adj j 
      camera.position.z = 40;
      
      renderer.render(scene, camera)
      
      //listen to scroll wheel
      window.addEventListener("wheel", function(e) {
        //camera.position.z += -1 * (e.deltaY / 20);
        
        //this seems a little smoother...
        if(e.deltaY < 0){
          camera.position.z++;
        } else {
          camera.position.z--;
        }

      }, true);
      
      
      function onMouseClick( event ) {
        if(!allowClicks){
          /*
          //reverse animation here
          var fadeoutBG = new TWEEN.Tween(coverPlane.material).to({opacity:0.0}, 1000).onComplete(function(){
            scene.remove(coverPlane)
          })
          fadeoutBG.start();
          */
          
          //run animations in reverse
          

          var flipOver = new TWEEN.Tween(openTile.rotation).to({y: 0}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.scale).to({x: 4, y: 4}, 1000).start();
            new TWEEN.Tween(coverPlane.material).to({opacity:0.0}, 1000).start();
          }).start();
          
          var changeScale = new TWEEN.Tween(openTile.scale).to({x: 1, y: 1}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.position).to({z: 0.1}, 1000).start();
          }).onComplete(function(){
            scene.remove(openTile);
            allowClicks = true;
          })

          //start everything
          flipOver.chain(changeScale);

        }
        
        // update the picking ray with the camera and mouse position
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( scene.children );
        
        if (typeof intersects[3] !== 'undefined' && allowClicks){
          allowClicks = false;
          scene.add( coverPlane );
          
          openTile = intersects[3].object;

          //animate scale change
          var changeScale = new TWEEN.Tween(openTile.scale).to({x: 2,y: 2}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.position).to({z: 1.0}, 1000).start();
          }).start();

          //is there a better const for pi?
          //animate flip over
          var flipOver = new TWEEN.Tween(openTile.rotation).to({y: 3.14159}, 1000).onStart(function(){
            new TWEEN.Tween(openTile.scale).to({x: 5, y: 2.5}, 1000).start();
            new TWEEN.Tween(coverPlane.material).to({opacity:0.5}, 1000).start()
          })

          //start everything
          changeScale.chain(flipOver);
        }
      }
      
      window.addEventListener( 'click', onMouseClick, false );
      
      renderer.setAnimationLoop(() => {
        TWEEN.update();
        renderer.render(scene, camera);
      });
		</script>

    <!-- include the Glitch button to show what the webpage is about and
          to make it easier for folks to view source and remix -->
    <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
    <script src="https://button.glitch.me/button.js"></script>
  </body>
</html>

<!--
TODO:
remove tile from scene when you're done!!!!!
add loading bar (texture gif animation onto 2d plane then make it go away when js is done loading...)
force mosaic OP images to be power of two (128x128)

in order to add text, we will have to draw to canvas, then apply as mesh surface for each individual.....
possibly pre-render and display as back mesh texture, then overlay with the 'real element' later? 

get working for touch...

advanced: change LOD as images are zoomed in? 

ray intersections on borders don't work...
-->