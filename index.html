<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>mosaicmosaic</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.0/tween.umd.js"></script>
    <script type="text/javascript" src="map.json"></script>
		<script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      
      /*
      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      var cube = new THREE.Mesh( geometry, material );
      scene.add( cube );
      */
      
      //100x100 to test out...
      
      //tileSize must be set to 2 but everything else is OK
    
      let width = dataMap.length;
      let height = dataMap[0].length;
      
      let tileSize = 2;
      
      
      for(var i = 0; i < width; i++){
        for(var j = 0; j < height; j++){
          //var geometry = new THREE.PlaneBufferGeometry( tileSize, tileSize, 32 );
          var geometry = new THREE.BoxBufferGeometry( tileSize, tileSize, 0.01);
          
          //find asset here.... need to cache on S3 to get real benefits.
          //three CDN is kind of crappy 
          //address example is https://quin2pm.s3.us-east-2.amazonaws.com/XXX.jpg
          const loader = new THREE.TextureLoader();
          const texString = "https://quin2pm.s3.us-east-2.amazonaws.com/" + dataMap[i][j] + ".jpg";
          
        
          var materials = [
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {map: loader.load(texString)} ),
            new THREE.MeshBasicMaterial( {color: 0x00FF00} ),
          ]
          
          //var material = new THREE.MeshBasicMaterial( {map: loader.load(texString), side: THREE.FrontSide} );
          
          var plane = new THREE.Mesh( geometry, materials);
          scene.add( plane );
          plane.position.set(j, -1 * i, 0.1);
        }
      }
      
      //yeet
      camera.position.x = ((height/4) * tileSize);
      camera.position.y = -((width/4) * tileSize)
      
      //scroll wheel to adj j 
      camera.position.z = 40;
      
      renderer.render(scene, camera)
      
      /*
      function animate() {
	      requestAnimationFrame( animate );
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
	      renderer.render( scene, camera );
      }
      animate();
      */
      
      //add loading bar...
      //idea: change LOD as we zoom in?
      
      //listen to scroll wheel
      window.addEventListener("wheel", function(e) {
        //camera.position.z += -1 * (e.deltaY / 20);
        
        //this seems a little smoother...
        if(e.deltaY < 0){
          camera.position.z++;
        } else {
          camera.position.z--;
        }
      
        //renderer.render(scene, camera)
        // code to increment object.position.z 
      }, true);
      
      
      function onMouseClick( event ) {
        // update the picking ray with the camera and mouse position
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( scene.children );
        
        //intersects[ 3 ].object.material.color.set( 0xff0000 );
        
        var changeScale = new TWEEN.Tween(intersects[3].object.scale).to({x: 2,y: 2}, 1000).onStart(function(){
          new TWEEN.Tween(intersects[3].object.position).to({z: 1.0}, 1000).start();
        }).start();
        
        //is there a better const for pi?
        var flipOver = new TWEEN.Tween(intersects[3].object.rotation).to({y: 3.14159}, 1000).onStart(function(){
          new TWEEN.Tween(intersects[3].object.scale).to({x: 5, y: 2.5}, 1000).start();
        })
        
        changeScale.chain(flipOver);
        
        
        //tweenInflate.chain(tweenDeflate);
        
        /*
        intersects[ 3 ].object.scale.x = 2.0;
        intersects[ 3 ].object.scale.y = 2.0;
        
        
        intersects[ 3 ].object.position.z = 1.0;
        */
        /*
        for ( var i = 0; i < intersects.length; i++ ) {

          intersects[ i ].object.material.color.set( 0xff0000 );

        }
        */

        //renderer.render( scene, camera );
      }
      
      window.addEventListener( 'click', onMouseClick, false );
      
      renderer.setAnimationLoop(() => {
        TWEEN.update();
        renderer.render(scene, camera);
      });
		</script>

    <!-- include the Glitch button to show what the webpage is about and
          to make it easier for folks to view source and remix -->
    <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
    <script src="https://button.glitch.me/button.js"></script>
  </body>
</html>

<!--
TODO:
add drop shadow across entire scene when obj is expanded, and freeze clicks.
set up 'put back' animation that will reverse trnasformation on click, then delete mesh from scene. 
add loading bar. 
force mosaic OP images to be power of two (128x128)

in order to add text, we will have to draw to canvas, then apply as mesh surface for each individual.....
possibly pre-render and display as back mesh texture, then overlay with the 'real element' later? 

get working for touch...
-->