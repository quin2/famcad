<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>mosaicmosaic</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.0/tween.umd.js"></script>
    <script type="text/javascript" src="map.json"></script>
		<script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
    
      let width = dataMap.length;
      let height = dataMap[0].length;
      
      let tileSize = 2;
      
      var allowClicks = true;
      
      //make covering plane for use later.
      var coverObj = new THREE.PlaneBufferGeometry(dataMap[0].length *tileSize, dataMap.length *tileSize, 32 );
      var coverPlaneMaterial = new THREE.MeshBasicMaterial( {color: 0x000000, opacity: 0.0, transparent: true} );
      var coverPlane = new THREE.Mesh( coverObj, coverPlaneMaterial);
      coverPlane.position.z = 0.2 //get it close to original grid...
      coverPlane.position.x = (dataMap[0].length/tileSize)
      coverPlane.position.y = -1 * (dataMap.length / tileSize)
      
      for(var i = 0; i < width; i++){
        for(var j = 0; j < height; j++){
          var geometry = new THREE.BoxBufferGeometry( tileSize, tileSize, 0.1);
          
          //address example is https://quin2pm.s3.us-east-2.amazonaws.com/XXX.jpg
          const loader = new THREE.TextureLoader();
          const texString = "https://quin2pm.s3.us-east-2.amazonaws.com/" + dataMap[i][j] + ".jpg";
          
          var materials = [
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {color: 0x000000} ),
            new THREE.MeshBasicMaterial( {map: loader.load(texString)} ),
            new THREE.MeshBasicMaterial( {color: 0x00FF00} ),
          ]
          
          var plane = new THREE.Mesh( geometry, materials);
          scene.add( plane );
          plane.position.set(j, -1 * i, 0.1);
        }
      }
      
      //center camera
      camera.position.x = ((height/4) * tileSize);
      camera.position.y = -((width/4) * tileSize)
      
      //scroll wheel to adj j 
      camera.position.z = 40;
      
      renderer.render(scene, camera)
      
      //listen to scroll wheel
      window.addEventListener("wheel", function(e) {
        //camera.position.z += -1 * (e.deltaY / 20);
        
        //this seems a little smoother...
        if(e.deltaY < 0){
          camera.position.z++;
        } else {
          camera.position.z--;
        }

      }, true);
      
      
      function onMouseClick( event ) {
        if(!allowClicks){
          //reverse animation here
          scene.remove(coverPlane);
        }
        
        // update the picking ray with the camera and mouse position
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( scene.children );
        
        if (intersects.length > 0 && allowClicks){
          allowClicks = false;
          scene.add( coverPlane );

          //animate scale change
          var changeScale = new TWEEN.Tween(intersects[3].object.scale).to({x: 2,y: 2}, 1000).onStart(function(){
            new TWEEN.Tween(intersects[3].object.position).to({z: 1.0}, 1000).start();
          }).start();

          //is there a better const for pi?
          //animate flip over
          var flipOver = new TWEEN.Tween(intersects[3].object.rotation).to({y: 3.14159}, 1000).onStart(function(){
            new TWEEN.Tween(intersects[3].object.scale).to({x: 5, y: 2.5}, 1000).start();
            new TWEEN.Tween(coverPlane.material).to({opacity:0.5}, 1000).start()
          })

          //start everything
          changeScale.chain(flipOver);
        }
      }
      
      window.addEventListener( 'click', onMouseClick, false );
      
      renderer.setAnimationLoop(() => {
        TWEEN.update();
        renderer.render(scene, camera);
      });
		</script>

    <!-- include the Glitch button to show what the webpage is about and
          to make it easier for folks to view source and remix -->
    <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
    <script src="https://button.glitch.me/button.js"></script>
  </body>
</html>

<!--
TODO:
set up 'put back' animation that will reverse trnasformation on click, then delete mesh from scene. 
add loading bar. 
force mosaic OP images to be power of two (128x128)

in order to add text, we will have to draw to canvas, then apply as mesh surface for each individual.....
possibly pre-render and display as back mesh texture, then overlay with the 'real element' later? 

get working for touch...

advanced: change LOD as images are zoomed in? 
-->

<!--
state lifecycle:
click anwhere
click, freeze clicking action, make it so click = collapse
on next click, make click anwhere work again...
-->